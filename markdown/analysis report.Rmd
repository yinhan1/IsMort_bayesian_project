---
title: "Exponentiated Weibull -- Bayesian"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  bookdown::html_document2:
    number_sections: no
    fig_caption: true
    toc: true
    toc_float: true
    toc_depth: 3
    code_folding: hide
header-includes:
- \usepackage{graphicx}
- \usepackage{float}
editor_options:
  chunk_output_type: inline
---

```{r setup knit, include=FALSE}
knitr::opts_chunk$set(
	fig.align = "center",
	fig.pos = "H",
	message = FALSE,
	warning = FALSE,
	external = TRUE,
	echo = TRUE
)

library(tidyverse)
library(data.table)
library(magrittr)
library(ggsci)
library(kableExtra)

source("../scripts/functions.R")
```

```{r clean data}
is_data <- 
  readxl::read_excel("../data/IS_data.xlsx") %>% 
  clean_data(cols_to_numeric = c("Day after spray","Deaths")) %>%
  convert_to_death_status()

is_dummy <- 
  is_data %>% 
  filter(Population == "ACO") %>% 
  mutate(
    intercept = 1,
    infected = ifelse(Treatment == "Infected", 1, 0) + 0,
    female = ifelse(Sex == "Female", 1, 0) + 0,
    age_14 = ifelse(Age == 14, 1, 0) + 0,
    age_28 = ifelse(Age == 28, 1, 0) + 0
  ) %>% 
  dplyr::select(c(Day, intercept, infected, female, age_14, age_28))
```

```{r initials}
B <- 5000
a1 <- a2 <- 0

outcomes <- matrix(0, nrow = B + 1, ncol = ncol(is_dummy)-1+2)
colnames(outcomes) <- c("alpha", "theta", colnames(is_dummy)[-1])
# outcomes[1,] <- c(2,1.5,2,0,0,0,0) 
outcomes[1,] = c(1.9601476,1.5680993,2.0990947,-1.0179268,0.0554350,0.6578609,0.1803762)
```

```{r MH algorithm}
for(iter in 2:(B+1)){
  #### ---------------------- MH for shape ---------------------- ####
  # propose new shape
  log_shape_proposed = log_shape_sampler(log_alpha = log(outcomes[iter-1,1]),
                                     log_theta = log(outcomes[iter-1,2]),
                                     multiplier = 0.5
                                     )
  loglike = log_likelihood(data = is_dummy,
                           alpha = exp(log_shape_proposed[1]),
                           theta = exp(log_shape_proposed[2]),
                           coefs = outcomes[iter-1,3:ncol(outcomes)])
  if(loglike == 0){
    q1 = 0
  }else{
    # ratio of posterior 
    q1_post = 
      (
        loglike + 
        log(prior(alpha = exp(log_shape_proposed[1]),
                  theta = exp(log_shape_proposed[2]),
                  coefs = outcomes[iter-1,3:ncol(outcomes)])) -
        log_likelihood(data = is_dummy,
                       alpha = outcomes[iter-1,1],
                       theta = outcomes[iter-1,2],
                       coefs = outcomes[iter-1,3:ncol(outcomes)]) -
        log(prior(alpha = exp(log_shape_proposed[1]),
                  theta = exp(log_shape_proposed[2]),
                  coefs = outcomes[iter-1,3:ncol(outcomes)]))
      ) %>% 
      exp()
    # ratio of jacobian
    q1_jacobian = exp(log_shape_proposed[1])*exp(log_shape_proposed[2]) / (outcomes[iter-1,1]*outcomes[iter-1,2])
    q1 = q1_post * q1_jacobian %>% as.numeric()
  }
  # update shape
  if (runif(1) < q1) {
      outcomes[iter,1] = exp(log_shape_proposed[1])
      outcomes[iter,2] = exp(log_shape_proposed[2])
      a1 = a1 + 1
  }else{
      outcomes[iter,1] = outcomes[iter-1,1]
      outcomes[iter,2] = outcomes[iter-1,2]
    }
  
  #### ---------------------- MH for scale/coefs ---------------------- ####
  # propose new coefs
  coefs_proposed = coefs_sampler(coefs = outcomes[iter-1,3:ncol(outcomes)], 
                                 multiplier = 0.5)
  loglike = log_likelihood(data = is_dummy,
                           alpha = outcomes[iter,1],
                           theta = outcomes[iter,2],
                           coefs = coefs_proposed)
  if(loglike == 0 || is.nan(loglike)){
    q2 = 0
  }else{
    # ratio of posterior 
    q2 = 
      (
        loglike + 
        log(prior(alpha = outcomes[iter,1],
                  theta = outcomes[iter,2],
                  coefs = coefs_proposed)) -
        log_likelihood(data = is_dummy,
                       alpha = outcomes[iter,1],
                       theta = outcomes[iter,2],
                       coefs = outcomes[iter-1,3:ncol(outcomes)]) -
        log(prior(alpha = outcomes[iter,1],
                  theta = outcomes[iter,2],
                  coefs = outcomes[iter-1,3:ncol(outcomes)]))
      ) %>% 
      exp()
  }
  # update scale
  if (runif(1) < q2) {
      outcomes[iter,3:ncol(outcomes)] = coefs_proposed
      a2 = a2 + 1
  }else{
      outcomes[iter,3:ncol(outcomes)] = outcomes[iter-1,3:ncol(outcomes)]
  }
  
  if (iter %% 5000 == 0) {cat(paste0("iteration: ", iter, "\n"))}
}

# shape 
a1/B
# scale
a2/B

## more efficient
# cov(log(outcomes[5001:(B+1),1]), log(outcomes[5001:(B+1),2]))
# var(log(outcomes[5001:(B+1),1]))
# var(log(outcomes[5001:(B+1),2]))
# sa = matrix(c(0.0007258214,-0.001257686,-0.001257686,0.002547757), ncol=2)
# sb = cov(outcomes[5001:(B+1),3:7])
# burn-in
# take last value as initial values in next run
```

```{r plot}
as.data.frame(outcomes) %>% 
  mutate(iteration = c(1:nrow(outcomes))) %>% 
  reshape2::melt(id.vars = "iteration") %>% 
  ggplot(aes(x = iteration, y = value, color = variable)) +
  geom_line(size = 0.1) +
  facet_wrap(~variable, ncol = 2, scales = "free_y") +
  scale_color_nejm() +
  labs(y = "coefficients", color = "coefficients") +
  theme_minimal()
```

```{r thin draw and check autocorrelation}
post_dist <- 
  as.data.frame(outcomes) %>% 
  mutate(iteration = c(1:nrow(outcomes))) %>% 
  thin_draws(data = ., B = B, b = B/50) %>% 
  select(-iteration)

apply(post_dist, 2, function(column) acf(column))
```

```{r}
t_sequence <- 
```





















